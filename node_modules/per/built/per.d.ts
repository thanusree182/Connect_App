export declare type Sink<T> = (v: T) => boolean | void;
export declare type Source<TIn, TOut> = (sink: Sink<TOut>, value?: TIn) => boolean | void;
export declare type Init<TIn, TOut> = TOut | TOut[] | Source<TIn, TOut>;
export declare class Per<TIn, TOut> {
    forEach: Source<TIn, TOut>;
    constructor(valOrFunc: Init<TIn, TOut>, bindThis?: any);
    per<TOut2>(valOrFunc: Init<TOut, TOut2> | Per<TOut, TOut2>, bindThis?: any): Per<TIn, TOut2>;
    map<TOut2>(mapFunc: (value: TOut) => TOut2): Per<TIn, TOut2>;
    filter(predicate: (value: TOut) => boolean): Per<TIn, TOut>;
    concat(second: Init<TIn, TOut>, secondThis?: any): Per<TIn, TOut>;
    concat(second: Per<TIn, TOut>): Per<TIn, TOut>;
    skip(count: number): Per<TIn, TOut>;
    take(count: number): Per<TIn, TOut>;
    listen(untilFunc: (value: TOut) => boolean): Per<TIn, TOut>;
    reduceWithSeed<TReduced>(reducer: (left: TReduced, right: TOut) => TReduced, seed: TReduced): Per<TIn, TReduced>;
    reduceWithoutSeed(reducer: (left: TOut, right: TOut) => TOut): Per<TIn, TOut>;
    reduce(reducer: (left: TOut, right: TOut) => TOut): Per<TIn, TOut>;
    reduce<TReduced>(reducer: (left: TReduced, right: TOut) => TReduced, seed: TReduced): Per<TIn, TReduced>;
    into(ar: TOut[], limit?: number): Per<TIn, TOut>;
    submit(value: TIn): boolean | void;
    all(value?: TIn): TOut[];
    first(value?: TIn): TOut;
    last(value?: TIn): TOut;
    truthy(): Per<TIn, TOut>;
}
export default function per<TIn, TOut>(valOrFunc: Init<TIn, TOut> | Per<TIn, TOut>, bindThis?: any): Per<TIn, TOut>;
